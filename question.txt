import Application from './Application';

const run = async () => {
    const app = new Application();
    await app.setup();

    console.log('Setup finished, starting loop');

    let timePreviousFrame = performance.now();

    document.addEventListener('visibilitychange', () => {
        app.setRunning(!document.hidden);
        if (!document.hidden) {
            // Reset previous frame time to avoid a huge deltaTime spike
            timePreviousFrame = performance.now();
        }
    });

    const loop = (now: number) => {
        const deltaTime = (now - timePreviousFrame) / 1000;
        timePreviousFrame = now;

        if (app.isRunning()) {
            app.input();
            app.update(deltaTime);
            app.render();
        }

        requestAnimationFrame(loop);
    };

    requestAnimationFrame(loop);
};

run();

import Graphics from './Graphics';
import InputManager, { MouseButton } from './InputManager';
import Utils from './math/Utils';
import Vec2 from './math/Vec2';
import Body from './physics/Body';
import World from './physics/World';
import Demo from './samples/Demo';

export default class Application {
    private running = false;

    // Debug related properties
    private debug = true;
    private FPS = 0;
    private lastFPSUpdate = 0;

    private world: World;
    private bomb: Body | null;
    private demoIndex: number;

    constructor() {
        const gravity = new Vec2(0, -10);
        const iterations = 10;

        this.world = new World(gravity, iterations);
        this.bomb = null;
        this.demoIndex = 0;
    }

    isRunning = (): boolean => {
        return this.running;
    };

    setRunning = (newValue: boolean): void => {
        this.running = newValue;
    };

    setup = async (): Promise<void> => {
        InputManager.initialize();
        this.running = Graphics.openWindow();

        Demo.demo1(this.world);
    };

    input = (): void => {
        // Handle keyboard events
        while (InputManager.keyboardInputBuffer.length > 0) {
            const inputEvent = InputManager.keyboardInputBuffer.shift();

            if (!inputEvent) {
                return;
            }

            switch (inputEvent.type) {
                case 'keydown':
                    if (inputEvent.code === 'KeyA') {
                        World.accumulateImpulses = !World.accumulateImpulses;
                    }

                    if (inputEvent.code === 'KeyP') {
                        World.positionCorrection = !World.positionCorrection;
                    }

                    if (inputEvent.code === 'KeyW') {
                        World.warmStarting = !World.warmStarting;
                    }

                    if (inputEvent.code === 'Digit1') {
                        this.demoIndex = 0;
                        this.world.clear();
                        this.bomb = null;
                        Demo.demo1(this.world);
                    }

                    if (inputEvent.code === 'Digit2') {
                        this.demoIndex = 1;
                        this.world.clear();
                        this.bomb = null;
                        Demo.demo2(this.world);
                    }

                    // ...

                    if (inputEvent.code === 'Digit4') {
                        this.demoIndex = 1;
                        this.world.clear();
                        this.bomb = null;
                        Demo.demo4(this.world);
                    }

                    // ....

                    if (inputEvent.code === 'Space') {
                        // Emit bomb
                        if (!this.bomb) {
                            const bomb = new Body();
                            bomb.set(new Vec2(1, 1), 50);
                            bomb.friction = 0.2;
                            this.bomb = bomb;
                            this.bomb.color = 'rgba(102, 230, 102, 1)';
                            this.world.add(bomb);
                        }

                        this.bomb.position.set(Utils.random(-15, 10), 10);
                        this.bomb.rotation = Utils.random(-1.5, 1.5);
                        this.bomb.velocity = Vec2.scale(-1.5, this.bomb.position);
                        this.bomb.angularVelocity = Utils.random(-20, 20);
                    }
                    break;
                case 'keyup':
                    // TODO: do something
                    break;
            }
        }

        // Handle mouse move events
        while (InputManager.mouseMoveBuffer.length > 0) {
            const inputEvent = InputManager.mouseMoveBuffer.shift();

            if (!inputEvent) {
                return;
            }
        }

        // Handle mouse click events
        while (InputManager.mouseInputBuffer.length > 0) {
            const inputEvent = InputManager.mouseInputBuffer.shift();

            if (!inputEvent) {
                return;
            }

            switch (inputEvent.type) {
                case 'mousedown':
                    switch (inputEvent.button) {
                        case MouseButton.LEFT:
                            // TODO: do something
                            break;
                        case MouseButton.RIGHT:
                            // TODO: do something
                            break;
                    }
                    break;
                case 'mouseup':
                    // TODO: do something
                    break;
            }
        }
    };

    update = (deltaTime: number): void => {
        if (this.debug && (!this.lastFPSUpdate || performance.now() - this.lastFPSUpdate > 1000)) {
            this.lastFPSUpdate = performance.now();
            this.FPS = 1 / deltaTime;
        }

        this.world.step(deltaTime);
    };

    render = (): void => {
        Graphics.clearScreen();

        if (this.debug) {
            Graphics.drawText(
                `${Demo.demoStrings[this.demoIndex]} (FPS: ${this.FPS.toFixed(2)})`,
                50,
                50,
                18,
                'arial',
                'orange',
            );
            Graphics.drawText(
                `(A)ccumulation ${World.accumulateImpulses ? 'ON' : 'OFF'}`,
                50,
                75,
                18,
                'arial',
                'orange',
            );

            Graphics.drawText(
                `(P)osition Correction ${World.positionCorrection ? 'ON' : 'OFF'}`,
                50,
                100,
                18,
                'arial',
                'orange',
            );

            Graphics.drawText(`(W)arm Starting ${World.warmStarting ? 'ON' : 'OFF'}`, 50, 125, 18, 'arial', 'orange');
        }

        for (const body of this.world.bodies) {
            Graphics.drawBody(body);
        }

        for (const joint of this.world.joints) {
            Graphics.drawJoint(joint);
        }

        for (const arbiter of this.world.arbiters.values()) {
            for (const contact of arbiter.contacts) {
                Graphics.drawContactPoint(contact, 'red');
            }
        }
    };
}

import Mat22 from './math/Mat22';
import Vec2 from './math/Vec2';
import { Contact } from './physics/Arbiter';
import Body from './physics/Body';
import Joint from './physics/Joint';

export default class Graphics {
    static windowWidth: number;
    static windowHeight: number;
    static canvas: HTMLCanvasElement;
    static ctx: CanvasRenderingContext2D;

    static zoom = 50; // pixels per world unit
    static pan = new Vec2(0, 0);

    static width = (): number => {
        return this.windowWidth;
    };

    static height = (): number => {
        return this.windowHeight;
    };

    static openWindow = (): boolean => {
        const canvas = document.getElementById('gameCanvas') as HTMLCanvasElement;
        const ctx = canvas.getContext('2d');

        if (!ctx) {
            console.error('Failed to get 2D context for the canvas.');
            return false;
        }

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        this.canvas = canvas;
        this.ctx = ctx;
        this.windowWidth = window.innerWidth;
        this.windowHeight = window.innerHeight;

        return true;
    };

    static clearScreen = (): void => {
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    };

    static drawFillCircle = (x: number, y: number, radius: number, color: string): void => {
        this.ctx.beginPath();
        this.ctx.arc(x, y, radius, 0, Math.PI * 2);
        this.ctx.fillStyle = color;
        this.ctx.fill();
    };

    static drawText = (
        text: string,
        x: number,
        y: number,
        fontSize: number = 20,
        fontFamily: string = 'Arial',
        color: string = 'white',
        align: CanvasTextAlign = 'left',
        baseline: CanvasTextBaseline = 'middle',
    ): void => {
        this.ctx.save();
        this.ctx.fillStyle = color;
        this.ctx.font = `${fontSize}px ${fontFamily}`;
        this.ctx.textAlign = align;
        this.ctx.textBaseline = baseline;
        this.ctx.fillText(text, x, y);
        this.ctx.restore();
    };

    static worldToScreen(v: Vec2): Vec2 {
        return new Vec2(
            (v.x - this.pan.x) * this.zoom + this.windowWidth / 2,
            this.windowHeight / 2 - (v.y - this.pan.y) * this.zoom,
        );
    }

    // TODO: can we generalize drawing to world screen?
    static drawContactPoint = (contact: Contact, color: string): void => {
        const v = this.worldToScreen(contact.position);
        this.ctx.beginPath();
        this.ctx.arc(v.x, v.y, 5, 0, Math.PI * 2);
        this.ctx.fillStyle = color;
        this.ctx.fill();
    };

    // TODO: can we generalize drawing to world screen?
    static drawBody = (body: Body): void => {
        const R = new Mat22(body.rotation);
        const x = body.position;
        const h = Vec2.scale(0.5, body.width);

        const v1 = this.worldToScreen(Vec2.add(x, Mat22.multiply(R, new Vec2(-h.x, -h.y))));
        const v2 = this.worldToScreen(Vec2.add(x, Mat22.multiply(R, new Vec2(h.x, -h.y))));
        const v3 = this.worldToScreen(Vec2.add(x, Mat22.multiply(R, new Vec2(h.x, h.y))));
        const v4 = this.worldToScreen(Vec2.add(x, Mat22.multiply(R, new Vec2(-h.x, h.y))));

        this.ctx.strokeStyle = body.color;
        this.ctx.beginPath();
        this.ctx.moveTo(v1.x, v1.y);
        this.ctx.lineTo(v2.x, v2.y);
        this.ctx.lineTo(v3.x, v3.y);
        this.ctx.lineTo(v4.x, v4.y);
        this.ctx.lineTo(v1.x, v1.y);
        this.ctx.closePath();
        this.ctx.stroke();
    };

    // TODO: can we generalize drawing to world screen?
    static drawJoint = (joint: Joint, color = 'rgba(128, 128, 204, 1)'): void => {
        if (!joint.body1 || !joint.body2) {
            throw new Error('One or more bodies not initialized in Joint');
        }

        const b1 = joint.body1;
        const b2 = joint.body2;

        const R1 = new Mat22(b1.rotation);
        const R2 = new Mat22(b2.rotation);

        const x1 = b1.position;
        const p1 = Vec2.add(x1, Mat22.multiply(R1, joint.localAnchor1));
        const x2 = b2.position;
        const p2 = Vec2.add(x2, Mat22.multiply(R2, joint.localAnchor2));

        // Convert physics/world coordinates to canvas coordinates
        const sx1 = Graphics.worldToScreen(x1);
        const sp1 = Graphics.worldToScreen(p1);
        const sx2 = Graphics.worldToScreen(x2);
        const sp2 = Graphics.worldToScreen(p2);

        this.ctx.strokeStyle = color;

        this.ctx.beginPath();

        // Line from body1 center to its anchor
        this.ctx.moveTo(sx1.x, sx1.y);
        this.ctx.lineTo(sp1.x, sp1.y);

        // Line from body2 center to its anchor
        this.ctx.moveTo(sx2.x, sx2.y);
        this.ctx.lineTo(sp2.x, sp2.y);

        this.ctx.stroke();
    };
}

import Vec2 from './Vec2';

export default class Mat22 {
    col1: Vec2;
    col2: Vec2;

    constructor();
    constructor(col1: Vec2, col2: Vec2);
    constructor(angle: number);

    constructor(a?: Vec2 | number, b?: Vec2) {
        if (a === undefined && !b) {
            this.col1 = new Vec2();
            this.col2 = new Vec2();
        } else if (typeof a === 'number' && !b) {
            const c = Math.cos(a);
            const s = Math.sin(a);

            this.col1 = new Vec2(c, s);
            this.col2 = new Vec2(-s, c);
        } else if (a instanceof Vec2 && b instanceof Vec2) {
            this.col1 = a;
            this.col2 = b;
        } else {
            throw new Error('Invalid constructor arguments');
        }
    }

    transpose = (): Mat22 => {
        return new Mat22(new Vec2(this.col1.x, this.col2.x), new Vec2(this.col1.y, this.col2.y));
    };

    invert = (): Mat22 => {
        const a = this.col1.x;
        const b = this.col2.x;
        const c = this.col1.y;
        const d = this.col2.y;

        const m = new Mat22();
        let det = a * d - b * c;

        if (det === 0) {
            throw new Error('Determinant in 2x2 matrix cannot be 0');
        }

        det = 1 / det;

        m.col1.x = det * d;
        m.col1.y = -det * c;
        m.col2.x = -det * b;
        m.col2.y = det * a;

        return m;
    };

    /** Operator + */
    static add = (a: Mat22, b: Mat22): Mat22 => {
        return new Mat22(Vec2.add(a.col1, b.col1), Vec2.add(a.col2, b.col2));
    };

    /** Operator * for matrix-vector multiplication */
    static multiply(a: Mat22, v: Vec2): Vec2;

    /** Operator * for matrix-matrix multiplication */
    static multiply(a: Mat22, b: Mat22): Mat22;

    static multiply(a: Mat22, b: Mat22 | Vec2): Vec2 | Mat22 {
        if (a instanceof Mat22 && b instanceof Mat22) {
            return new Mat22(Mat22.multiply(a, b.col1), Mat22.multiply(a, b.col2));
        }

        if (a instanceof Mat22 && b instanceof Vec2) {
            return new Vec2(a.col1.x * b.x + a.col2.x * b.y, a.col1.y * b.x + a.col2.y * b.y);
        }

        throw new Error('Invalid arguments');
    }

    static abs = (a: Mat22): Mat22 => {
        return new Mat22(Vec2.abs(a.col1), Vec2.abs(a.col2));
    };
}

export default class Utils {
    static clamp = (value: number, low: number, high: number): number => {
        return Math.max(low, Math.min(value, high));
    };

    /** Random number in range [-1,1] */
    static random(): number;

    /** Random number in range [low,high] */
    static random(low: number, high: number): number;

    static random(low?: number, high?: number): number {
        if (low === undefined && high === undefined) {
            return Math.random() * 2 - 1;
        }

        if (low !== undefined && high !== undefined) {
            return Math.random() * (high - low) + low;
        }

        throw new Error('Invalid arguments');
    }
}

export default class Vec2 {
    x: number;
    y: number;

    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }

    clone = (): Vec2 => {
        return new Vec2(this.x, this.y);
    };

    set = (x: number, y: number): void => {
        this.x = x;
        this.y = y;
    };

    /** Operator - */
    negate = (): Vec2 => {
        return new Vec2(-this.x, -this.y);
    };

    /** Operator += */
    add = (v: Vec2): void => {
        this.x += v.x;
        this.y += v.y;
    };

    /** Operator -= */
    sub = (v: Vec2): void => {
        this.x -= v.x;
        this.y -= v.y;
    };

    /** Operator *= */
    scale = (a: number): void => {
        this.x *= a;
        this.y *= a;
    };

    /** Magnitude of the Vector */
    length = (): number => {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    };

    /** Dot product between two vectors */
    static dot = (a: Vec2, b: Vec2): number => {
        return a.x * b.x + a.y * b.y;
    };

    /** Scalar 2D cross product */
    static cross(a: Vec2, b: Vec2): number;

    /** Vector in the +90° (counterclockwise) perpendicular direction scaled by a */
    static cross(a: Vec2, s: number): Vec2;

    /** Vector in the -90° (clockwise) perpendicular direction scaled by a */
    static cross(s: number, a: Vec2): Vec2;

    static cross(a: Vec2 | number, b: Vec2 | number): number | Vec2 {
        if (a instanceof Vec2 && b instanceof Vec2) {
            return a.x * b.y - a.y * b.x;
        }

        if (a instanceof Vec2 && typeof b === 'number') {
            return new Vec2(b * a.y, -b * a.x);
        }

        if (typeof a === 'number' && b instanceof Vec2) {
            return new Vec2(-a * b.y, a * b.x);
        }

        throw new Error('Invalid arguments');
    }

    /** Operator + */
    static add = (a: Vec2, b: Vec2): Vec2 => {
        return new Vec2(a.x + b.x, a.y + b.y);
    };

    /** Operator - */
    static sub = (a: Vec2, b: Vec2): Vec2 => {
        return new Vec2(a.x - b.x, a.y - b.y);
    };

    /** Operator * */
    static scale = (s: number, v: Vec2): Vec2 => {
        return new Vec2(s * v.x, s * v.y);
    };

    static abs = (a: Vec2): Vec2 => {
        return new Vec2(Math.abs(a.x), Math.abs(a.y));
    };
}

import Utils from '../math/Utils';
import Vec2 from '../math/Vec2';
import Body from './Body';
import { Collide } from './Collide';
import World from './World';

export class Edges {
    inEdge1: number;
    outEdge1: number;
    inEdge2: number;
    outEdge2: number;

    constructor() {
        this.inEdge1 = 0;
        this.outEdge1 = 0;
        this.inEdge2 = 0;
        this.outEdge2 = 0;
    }
}

export class FeaturePair {
    e: Edges;
    value: number;

    constructor(value = 0) {
        this.e = new Edges();
        this.value = value;
    }

    clone = (): FeaturePair => {
        const copy = new FeaturePair();

        copy.e.inEdge1 = this.e.inEdge1;
        copy.e.outEdge1 = this.e.outEdge1;
        copy.e.inEdge2 = this.e.inEdge2;
        copy.e.outEdge2 = this.e.outEdge2;
        copy.value = this.value;

        return copy;
    };

    flip = (): void => {
        // Swap inEdge1 <-> inEdge2
        [this.e.inEdge1, this.e.inEdge2] = [this.e.inEdge2, this.e.inEdge1];

        // Swap outEdge1 <-> outEdge2
        [this.e.outEdge1, this.e.outEdge2] = [this.e.outEdge2, this.e.outEdge1];
    };
}

export class Contact {
    position: Vec2;
    normal: Vec2;
    r1: Vec2;
    r2: Vec2;
    separation: number;
    Pn: number; // accumulated normal impulse
    Pt: number; // accumulated tangent impulse
    Pnb: number; // accumulated normal impulse for position bias
    massNormal: number;
    massTangent: number;
    bias: number;
    feature: FeaturePair;

    constructor() {
        this.position = new Vec2();
        this.normal = new Vec2();
        this.r1 = new Vec2();
        this.r2 = new Vec2();
        this.separation = 0;

        this.Pn = 0;
        this.Pt = 0;
        this.Pnb = 0;

        this.massNormal = 0;
        this.massTangent = 0;
        this.bias = 0;
        this.feature = new FeaturePair();
    }
}

export class ArbiterKey {
    static getKey = (b1: Body, b2: Body): number => {
        if (b1.id < b2.id) {
            return (b1.id << 16) | (b2.id & 0xffff);
        } else {
            return (b2.id << 16) | (b1.id & 0xffff);
        }
    };
}

export class Arbiter {
    MAX_POINTS = 2;

    contacts: Contact[];
    numContacts: number;

    body1: Body;
    body2: Body;

    // Combined friction
    friction: number;

    constructor(b1: Body, b2: Body) {
        this.contacts = [new Contact(), new Contact()];

        if (b1.id < b2.id) {
            this.body1 = b1;
            this.body2 = b2;
        } else {
            this.body1 = b2;
            this.body2 = b1;
        }

        this.numContacts = Collide.checkCollision(this.contacts, this.body1, this.body2);

        this.friction = Math.sqrt(this.body1.friction * this.body2.friction);
    }

    update = (newContacts: Contact[], numNewContacts: number): void => {
        const mergedContacts = [new Contact(), new Contact()];

        for (let i = 0; i < numNewContacts; i++) {
            const cNew = newContacts[i];
            let k = -1;
            for (let j = 0; j < this.numContacts; ++j) {
                const cOld = this.contacts[j];
                if (cNew.feature.value === cOld.feature.value) {
                    k = j;
                    break;
                }
            }
            if (k > -1) {
                const cOld = this.contacts[k];
                // TODO: check if mergedContacts[i] = newContacts[i]; would be equivalent to next two lines
                mergedContacts[i] = new Contact();
                Object.assign(mergedContacts[i], newContacts[i]);
                const c = mergedContacts[i];

                if (World.warmStarting) {
                    c.Pn = cOld.Pn;
                    c.Pt = cOld.Pt;
                    c.Pnb = cOld.Pnb;
                } else {
                    c.Pn = 0.0;
                    c.Pt = 0.0;
                    c.Pnb = 0.0;
                }
            } else {
                mergedContacts[i] = newContacts[i];
            }
        }

        for (let i = 0; i < numNewContacts; i++) {
            this.contacts[i] = mergedContacts[i];
        }

        this.numContacts = numNewContacts;
    };

    preStep = (invDt: number): void => {
        // Allowed penetration & bias factor
        const kAllowedPenetration = 0.01;
        const kBiasFactor = World.positionCorrection ? 0.2 : 0.0;

        for (let i = 0; i < this.numContacts; ++i) {
            const c = this.contacts[i];

            // Relative positions
            const r1 = Vec2.sub(c.position, this.body1.position);
            const r2 = Vec2.sub(c.position, this.body2.position);

            // Normal mass computation
            const rn1 = Vec2.dot(r1, c.normal);
            const rn2 = Vec2.dot(r2, c.normal);
            let kNormal = this.body1.invMass + this.body2.invMass;
            kNormal +=
                this.body1.invI * (Vec2.dot(r1, r1) - rn1 * rn1) + this.body2.invI * (Vec2.dot(r2, r2) - rn2 * rn2);
            c.massNormal = 1.0 / kNormal;

            // Tangent mass computation
            const tangent = Vec2.cross(c.normal, 1);
            const rt1 = Vec2.dot(r1, tangent);
            const rt2 = Vec2.dot(r2, tangent);
            let kTangent = this.body1.invMass + this.body2.invMass;
            kTangent +=
                this.body1.invI * (Vec2.dot(r1, r1) - rt1 * rt1) + this.body2.invI * (Vec2.dot(r2, r2) - rt2 * rt2);
            c.massTangent = 1 / kTangent;

            // Bias computation
            c.bias = -kBiasFactor * invDt * Math.min(0, c.separation + kAllowedPenetration);

            if (World.accumulateImpulses) {
                // Apply accumulated impulses
                const P = Vec2.add(Vec2.scale(c.Pn, c.normal), Vec2.scale(c.Pt, tangent));

                this.body1.velocity.sub(Vec2.scale(this.body1.invMass, P));
                this.body1.angularVelocity -= this.body1.invI * Vec2.cross(r1, P);

                this.body2.velocity.add(Vec2.scale(this.body2.invMass, P));
                this.body2.angularVelocity += this.body2.invI * Vec2.cross(r2, P);
            }
        }
    };

    applyImpulse = (): void => {
        const b1 = this.body1;
        const b2 = this.body2;

        for (let i = 0; i < this.numContacts; ++i) {
            const c = this.contacts[i];
            c.r1 = Vec2.sub(c.position, b1.position);
            c.r2 = Vec2.sub(c.position, b2.position);

            // Linear velocity of the center of mass of body 1 and 2.
            let lv1 = Vec2.sub(b1.velocity, Vec2.cross(b1.angularVelocity, c.r1));
            let lv2 = Vec2.add(b2.velocity, Vec2.cross(b2.angularVelocity, c.r2));

            // Relative velocity at contact
            let dv = Vec2.sub(lv2, lv1);

            // Compute normal impulse
            const vn = Vec2.dot(dv, c.normal);
            let dPn = c.massNormal * (-vn + c.bias);

            if (World.accumulateImpulses) {
                // Clamp the accumulated impulse
                const Pn0 = c.Pn;
                c.Pn = Math.max(Pn0 + dPn, 0);
                dPn = c.Pn - Pn0;
            } else {
                dPn = Math.max(dPn, 0);
            }

            // Apply contact impulse
            const Pn = Vec2.scale(dPn, c.normal);

            b1.velocity.sub(Vec2.scale(b1.invMass, Pn));
            b1.angularVelocity -= b1.invI * Vec2.cross(c.r1, Pn);

            b2.velocity.add(Vec2.scale(b2.invMass, Pn));
            b2.angularVelocity += b2.invI * Vec2.cross(c.r2, Pn);

            // Linear velocity of the center of mass of body 1 and 2.
            lv1 = Vec2.sub(b1.velocity, Vec2.cross(b1.angularVelocity, c.r1));
            lv2 = Vec2.add(b2.velocity, Vec2.cross(b2.angularVelocity, c.r2));

            // Relative velocity at contact
            dv = Vec2.sub(lv2, lv1);

            const tangent = Vec2.cross(c.normal, 1);
            const vt = Vec2.dot(dv, tangent);
            let dPt = c.massTangent * -vt;

            if (World.accumulateImpulses) {
                // Compute friction impulse
                const maxPt = this.friction * c.Pn;

                // Clamp friction
                const oldTangentImpulse = c.Pt;
                c.Pt = Utils.clamp(oldTangentImpulse + dPt, -maxPt, maxPt);
                dPt = c.Pt - oldTangentImpulse;
            } else {
                const maxPt = this.friction * dPn;
                dPt = Utils.clamp(dPt, -maxPt, maxPt);
            }

            // Apply contact impulse
            const Pt = Vec2.scale(dPt, tangent);

            b1.velocity.sub(Vec2.scale(b1.invMass, Pt));
            b1.angularVelocity -= b1.invI * Vec2.cross(c.r1, Pt);

            b2.velocity.add(Vec2.scale(b2.invMass, Pt));
            b2.angularVelocity += b2.invI * Vec2.cross(c.r2, Pt);
        }
    };
}

import Vec2 from '../math/Vec2';

export default class Body {
    static _nextId = 0;
    id: number;

    position: Vec2;
    rotation: number;

    velocity: Vec2;
    angularVelocity: number;

    force: Vec2;
    torque: number;

    width: Vec2;

    friction: number;
    mass: number;
    invMass: number;
    I: number;
    invI: number;

    color: string;

    constructor() {
        this.id = Body._nextId++;

        this.position = new Vec2();
        this.rotation = 0.0;
        this.velocity = new Vec2();
        this.angularVelocity = 0.0;
        this.force = new Vec2();
        this.torque = 0.0;
        this.friction = 0.2;

        this.width = new Vec2();
        this.mass = Number.MAX_VALUE;
        this.invMass = 0.0;
        this.I = Number.MAX_VALUE;
        this.invI = 0.0;

        this.color = 'white';
    }

    set = (w: Vec2, m: number): void => {
        this.position.set(0.0, 0.0);
        this.rotation = 0.0;
        this.velocity.set(0.0, 0.0);
        this.angularVelocity = 0.0;
        this.force.set(0.0, 0.0);
        this.torque = 0.0;
        this.friction = 0.2;

        this.width = w;
        this.mass = m;

        if (this.mass < Number.MAX_VALUE) {
            this.invMass = 1.0 / this.mass;
            this.I = (this.mass * (this.width.x * this.width.x + this.width.y * this.width.y)) / 12;
            this.invI = 1.0 / this.I;
        } else {
            this.invMass = 0.0;
            this.I = Number.MAX_VALUE;
            this.invI = 0.0;
        }
    };

    addForce = (f: Vec2): void => {
        this.force.add(f);
    };
}

// Box vertex and edge numbering:
//
//        ^ y
//        |
//        e1
//   v2 ------ v1
//    |        |
// e2 |        | e4  --> x
//    |        |
//   v3 ------ v4
//        e3
import Mat22 from '../math/Mat22';
import Vec2 from '../math/Vec2';
import { Contact, FeaturePair } from './Arbiter';
import Body from './Body';

export enum Axis {
    FACE_A_X,
    FACE_A_Y,
    FACE_B_X,
    FACE_B_Y,
}

export enum EdgeNumbers {
    NO_EDGE = 0,
    EDGE1,
    EDGE2,
    EDGE3,
    EDGE4,
}

export class ClipVertex {
    v: Vec2;
    fp: FeaturePair;

    constructor(value = 0) {
        this.v = new Vec2();
        this.fp = new FeaturePair(value);
    }

    clone = (): ClipVertex => {
        const cv = new ClipVertex();
        cv.v = this.v.clone();
        cv.fp.value = this.fp.value;

        cv.fp.e.inEdge1 = this.fp.e.inEdge1;
        cv.fp.e.outEdge1 = this.fp.e.outEdge1;
        cv.fp.e.inEdge2 = this.fp.e.inEdge2;
        cv.fp.e.outEdge2 = this.fp.e.outEdge2;

        return cv;
    };

    static clipSegmentToLine = (
        vOut: [ClipVertex, ClipVertex],
        vIn: [ClipVertex, ClipVertex],
        normal: Vec2,
        offset: number,
        clipEdge: EdgeNumbers,
    ): number => {
        // Start with no output points
        let numOut = 0;

        // Calculate the distance of end points to the line
        const distance0 = Vec2.dot(normal, vIn[0].v) - offset;
        const distance1 = Vec2.dot(normal, vIn[1].v) - offset;

        // If the points are behind the plane
        if (distance0 <= 0.0) vOut[numOut++] = vIn[0].clone();
        if (distance1 <= 0.0) vOut[numOut++] = vIn[1].clone();

        // If the points are on different sides of the plane
        if (distance0 * distance1 < 0.0) {
            // Find intersection point of edge and plane
            const interp = distance0 / (distance0 - distance1);
            vOut[numOut].v = Vec2.add(vIn[0].v, Vec2.scale(interp, Vec2.sub(vIn[1].v, vIn[0].v)));

            if (distance0 > 0.0) {
                vOut[numOut].fp = vIn[0].fp.clone();
                vOut[numOut].fp.e.inEdge1 = clipEdge;
                vOut[numOut].fp.e.inEdge2 = EdgeNumbers.NO_EDGE;
            } else {
                vOut[numOut].fp = vIn[1].fp.clone();
                vOut[numOut].fp.e.outEdge1 = clipEdge;
                vOut[numOut].fp.e.outEdge2 = EdgeNumbers.NO_EDGE;
            }
            ++numOut;
        }

        return numOut;
    };

    static computeIncidentEdge = (c: [ClipVertex, ClipVertex], h: Vec2, pos: Vec2, Rot: Mat22, normal: Vec2): void => {
        // The normal is from the reference box. Convert it
        // to the incident boxe's frame and flip sign.
        const rotT = Rot.transpose();
        const n = Vec2.scale(-1, Mat22.multiply(rotT, normal));
        const nAbs = Vec2.abs(n);

        // Choose edge based on largest normal component
        if (nAbs.x > nAbs.y) {
            if (Math.sign(n.x) > 0) {
                // +X edge
                c[0].v.set(h.x, -h.y);
                c[0].fp.e.inEdge2 = EdgeNumbers.EDGE3;
                c[0].fp.e.outEdge2 = EdgeNumbers.EDGE4;

                c[1].v.set(h.x, h.y);
                c[1].fp.e.inEdge2 = EdgeNumbers.EDGE4;
                c[1].fp.e.outEdge2 = EdgeNumbers.EDGE1;
            } else {
                // -X edge
                c[0].v.set(-h.x, h.y);
                c[0].fp.e.inEdge2 = EdgeNumbers.EDGE1;
                c[0].fp.e.outEdge2 = EdgeNumbers.EDGE2;

                c[1].v.set(-h.x, -h.y);
                c[1].fp.e.inEdge2 = EdgeNumbers.EDGE2;
                c[1].fp.e.outEdge2 = EdgeNumbers.EDGE3;
            }
        } else {
            if (Math.sign(n.y) > 0) {
                // +Y edge
                c[0].v.set(h.x, h.y);
                c[0].fp.e.inEdge2 = EdgeNumbers.EDGE4;
                c[0].fp.e.outEdge2 = EdgeNumbers.EDGE1;

                c[1].v.set(-h.x, h.y);
                c[1].fp.e.inEdge2 = EdgeNumbers.EDGE1;
                c[1].fp.e.outEdge2 = EdgeNumbers.EDGE2;
            } else {
                // -Y edge
                c[0].v.set(-h.x, -h.y);
                c[0].fp.e.inEdge2 = EdgeNumbers.EDGE2;
                c[0].fp.e.outEdge2 = EdgeNumbers.EDGE3;

                c[1].v.set(h.x, -h.y);
                c[1].fp.e.inEdge2 = EdgeNumbers.EDGE3;
                c[1].fp.e.outEdge2 = EdgeNumbers.EDGE4;
            }
        }

        // Transform to world space: v = pos + Rot * v
        c[0].v = Vec2.add(pos, Mat22.multiply(Rot, c[0].v));
        c[1].v = Vec2.add(pos, Mat22.multiply(Rot, c[1].v));
    };
}

export class Collide {
    // The normal points from A to B
    static checkCollision = (contacts: Contact[], bodyA: Body, bodyB: Body): number => {
        // Setup
        const hA = Vec2.scale(0.5, bodyA.width);
        const hB = Vec2.scale(0.5, bodyB.width);

        const posA = bodyA.position;
        const posB = bodyB.position;

        const RotA = new Mat22(bodyA.rotation);
        const RotB = new Mat22(bodyB.rotation);

        const RotAT = RotA.transpose();
        const RotBT = RotB.transpose();

        const dp = Vec2.sub(posB, posA);
        const dA = Mat22.multiply(RotAT, dp);
        const dB = Mat22.multiply(RotBT, dp);

        const C = Mat22.multiply(RotAT, RotB);
        const absC = Mat22.abs(C);
        const absCT = absC.transpose();

        // Box A faces
        const faceA = Vec2.sub(Vec2.sub(Vec2.abs(dA), hA), Mat22.multiply(absC, hB));
        if (faceA.x > 0.0 || faceA.y > 0.0) {
            return 0;
        }
        //	Vec2 faceB = Abs(dB) - absCT * hA - hB;
        // Box B faces
        const faceB = Vec2.sub(Vec2.sub(Vec2.abs(dB), Mat22.multiply(absCT, hA)), hB);
        if (faceB.x > 0.0 || faceB.y > 0.0) {
            return 0;
        }

        // Find best axis

        // Box A faces
        let axis = Axis.FACE_A_X;
        let separation = faceA.x;
        let normal = dA.x > 0.0 ? RotA.col1 : Vec2.scale(-1, RotA.col1);

        const relativeTol = 0.95;
        const absoluteTol = 0.01;

        if (faceA.y > relativeTol * separation + absoluteTol * hA.y) {
            axis = Axis.FACE_A_Y;
            separation = faceA.y;
            normal = dA.y > 0.0 ? RotA.col2 : Vec2.scale(-1, RotA.col2);
        }

        // Box B faces
        if (faceB.x > relativeTol * separation + absoluteTol * hB.x) {
            axis = Axis.FACE_B_X;
            separation = faceB.x;
            normal = dB.x > 0.0 ? RotB.col1 : Vec2.scale(-1, RotB.col1);
        }

        if (faceB.y > relativeTol * separation + absoluteTol * hB.y) {
            axis = Axis.FACE_B_Y;
            separation = faceB.y;
            normal = dB.y > 0.0 ? RotB.col2 : Vec2.scale(-1, RotB.col2);
        }

        // Setup clipping plane data based on the separating axis
        let frontNormal = new Vec2();
        let sideNormal = new Vec2();
        const incidentEdge: [ClipVertex, ClipVertex] = [new ClipVertex(), new ClipVertex()];
        let front = 0;
        let negSide = 0;
        let posSide = 0;
        let negEdge: EdgeNumbers = 0;
        let posEdge: EdgeNumbers = 0;

        // Compute the clipping lines and the line segment to be clipped.
        switch (axis) {
            case Axis.FACE_A_X:
                {
                    frontNormal = normal;
                    front = Vec2.dot(posA, frontNormal) + hA.x;
                    sideNormal = RotA.col2;
                    const side = Vec2.dot(posA, sideNormal);
                    negSide = -side + hA.y;
                    posSide = side + hA.y;
                    negEdge = EdgeNumbers.EDGE3;
                    posEdge = EdgeNumbers.EDGE1;
                    ClipVertex.computeIncidentEdge(incidentEdge, hB, posB, RotB, frontNormal);
                }
                break;
            case Axis.FACE_A_Y:
                {
                    frontNormal = normal;
                    front = Vec2.dot(posA, frontNormal) + hA.y;
                    sideNormal = RotA.col1;
                    const side = Vec2.dot(posA, sideNormal);
                    negSide = -side + hA.x;
                    posSide = side + hA.x;
                    negEdge = EdgeNumbers.EDGE2;
                    posEdge = EdgeNumbers.EDGE4;
                    ClipVertex.computeIncidentEdge(incidentEdge, hB, posB, RotB, frontNormal);
                }
                break;
            case Axis.FACE_B_X:
                {
                    frontNormal = Vec2.scale(-1, normal);
                    front = Vec2.dot(posB, frontNormal) + hB.x;
                    sideNormal = RotB.col2;
                    const side = Vec2.dot(posB, sideNormal);
                    negSide = -side + hB.y;
                    posSide = side + hB.y;
                    negEdge = EdgeNumbers.EDGE3;
                    posEdge = EdgeNumbers.EDGE1;
                    ClipVertex.computeIncidentEdge(incidentEdge, hA, posA, RotA, frontNormal);
                }
                break;
            case Axis.FACE_B_Y:
                {
                    frontNormal = Vec2.scale(-1, normal);
                    front = Vec2.dot(posB, frontNormal) + hB.y;
                    sideNormal = RotB.col1;
                    const side = Vec2.dot(posB, sideNormal);
                    negSide = -side + hB.x;
                    posSide = side + hB.x;
                    negEdge = EdgeNumbers.EDGE2;
                    posEdge = EdgeNumbers.EDGE4;
                    ClipVertex.computeIncidentEdge(incidentEdge, hA, posA, RotA, frontNormal);
                }
                break;
        }

        // clip other face with 5 box planes (1 face plane, 4 edge planes)

        const clipPoints1: [ClipVertex, ClipVertex] = [new ClipVertex(), new ClipVertex()];
        const clipPoints2: [ClipVertex, ClipVertex] = [new ClipVertex(), new ClipVertex()];
        let np = 0;

        // Clip to box side 1
        np = ClipVertex.clipSegmentToLine(clipPoints1, incidentEdge, Vec2.scale(-1, sideNormal), negSide, negEdge);

        if (np < 2) {
            return 0;
        }

        // Clip to negative box side 1
        np = ClipVertex.clipSegmentToLine(clipPoints2, clipPoints1, sideNormal, posSide, posEdge);

        if (np < 2) {
            return 0;
        }

        // Now clipPoints2 contains the clipping points.
        // Due to roundoff, it is possible that clipping removes all points.

        let numContacts = 0;
        for (let i = 0; i < 2; i++) {
            const separation = Vec2.dot(frontNormal, clipPoints2[i].v) - front;

            if (separation <= 0) {
                contacts[numContacts].separation = separation;
                contacts[numContacts].normal = normal;

                // slide contact point onto reference face (easy to cull)
                contacts[numContacts].position = Vec2.sub(clipPoints2[i].v, Vec2.scale(separation, frontNormal));
                contacts[numContacts].feature = clipPoints2[i].fp;

                if (axis === Axis.FACE_B_X || axis === Axis.FACE_B_Y) {
                    contacts[numContacts].feature.flip();
                }

                ++numContacts;
            }
        }

        return numContacts;
    };
}

import Mat22 from '../math/Mat22';
import Vec2 from '../math/Vec2';
import Body from './Body';
import World from './World';

export default class Joint {
    M: Mat22;
    localAnchor1: Vec2;
    localAnchor2: Vec2;
    r1: Vec2;
    r2: Vec2;
    bias: Vec2;
    P: Vec2; // accumulated impulse
    body1: Body | null;
    body2: Body | null;
    biasFactor: number;
    softness: number;

    constructor() {
        this.M = new Mat22();
        this.localAnchor1 = new Vec2();
        this.localAnchor2 = new Vec2();
        this.r1 = new Vec2();
        this.r2 = new Vec2();
        this.bias = new Vec2();

        this.body1 = null;
        this.body2 = null;

        this.biasFactor = 0.2;
        this.softness = 0;

        this.P = new Vec2();
    }

    set = (b1: Body, b2: Body, anchor: Vec2): void => {
        this.body1 = b1;
        this.body2 = b2;

        const Rot1 = new Mat22(this.body1.rotation);
        const Rot2 = new Mat22(this.body2.rotation);
        const Rot1T = Rot1.transpose();
        const Rot2T = Rot2.transpose();

        this.localAnchor1 = Mat22.multiply(Rot1T, Vec2.sub(anchor, this.body1.position));
        this.localAnchor2 = Mat22.multiply(Rot2T, Vec2.sub(anchor, this.body2.position));

        this.P.set(0, 0);

        this.softness = 0;
        this.biasFactor = 0.2;
    };

    preStep = (invDt: number): void => {
        if (!this.body1 || !this.body2) {
            throw new Error('One or more bodies not initialized in Joint');
        }

        // Pre-compute anchors, mass matrix, and bias.
        const Rot1 = new Mat22(this.body1.rotation);
        const Rot2 = new Mat22(this.body2.rotation);

        this.r1 = Mat22.multiply(Rot1, this.localAnchor1);
        this.r2 = Mat22.multiply(Rot2, this.localAnchor2);

        // deltaV = deltaV0 + K * impulse
        // invM = [(1/m1 + 1/m2) * eye(2) - skew(r1) * invI1 * skew(r1) - skew(r2) * invI2 * skew(r2)]
        //      = [1/m1+1/m2     0    ] + invI1 * [r1.y*r1.y -r1.x*r1.y] + invI2 * [r1.y*r1.y -r1.x*r1.y]
        //        [    0     1/m1+1/m2]           [-r1.x*r1.y r1.x*r1.x]           [-r1.x*r1.y r1.x*r1.x]
        const K1 = new Mat22();
        K1.col1.x = this.body1.invMass + this.body2.invMass;
        K1.col1.y = 0.0;
        K1.col2.x = 0.0;
        K1.col2.y = this.body1.invMass + this.body2.invMass;

        const K2 = new Mat22();
        K2.col1.x = this.body1.invI * this.r1.y * this.r1.y;
        K2.col1.y = -this.body1.invI * this.r1.x * this.r1.y;
        K2.col2.x = -this.body1.invI * this.r1.x * this.r1.y;
        K2.col2.y = this.body1.invI * this.r1.x * this.r1.x;

        const K3 = new Mat22();
        K3.col1.x = this.body2.invI * this.r2.y * this.r2.y;
        K3.col1.y = -this.body2.invI * this.r2.x * this.r2.y;
        K3.col2.x = -this.body2.invI * this.r2.x * this.r2.y;
        K3.col2.y = this.body2.invI * this.r2.x * this.r2.x;

        const K = Mat22.add(Mat22.add(K1, K2), K3);
        K.col1.x += this.softness;
        K.col2.y += this.softness;

        this.M = K.invert();

        const p1 = Vec2.add(this.body1.position, this.r1);
        const p2 = Vec2.add(this.body2.position, this.r2);
        const dp = Vec2.sub(p2, p1);

        if (World.positionCorrection) {
            this.bias = Vec2.scale(-this.biasFactor * invDt, dp);
        } else {
            this.bias.set(0.0, 0.0);
        }

        if (World.warmStarting) {
            // Apply accumulated impulse.
            this.body1.velocity.sub(Vec2.scale(this.body1.invMass, this.P));
            this.body1.angularVelocity -= this.body1.invI * Vec2.cross(this.r1, this.P);

            this.body2.velocity.add(Vec2.scale(this.body2.invMass, this.P));
            this.body2.angularVelocity += this.body2.invI * Vec2.cross(this.r2, this.P);
        } else {
            this.P.set(0.0, 0.0);
        }
    };

    applyImpulse = (): void => {
        if (!this.body1 || !this.body2) {
            throw new Error('One or more bodies not initialized in Joint');
        }

        // Linear velocity of the center of mass of body 1 and 2.
        const lv1 = Vec2.sub(this.body1.velocity, Vec2.cross(this.body1.angularVelocity, this.r1));
        const lv2 = Vec2.add(this.body2.velocity, Vec2.cross(this.body2.angularVelocity, this.r2));

        // Relative velocity at contact
        const dv = Vec2.sub(lv2, lv1);

        const impulse = Mat22.multiply(this.M, Vec2.sub(Vec2.sub(this.bias, dv), Vec2.scale(this.softness, this.P)));

        this.body1.velocity.sub(Vec2.scale(this.body1.invMass, impulse));
        this.body1.angularVelocity -= this.body1.invI * Vec2.cross(this.r1, impulse);

        this.body2.velocity.add(Vec2.scale(this.body2.invMass, impulse));
        this.body2.angularVelocity += this.body2.invI * Vec2.cross(this.r2, impulse);

        this.P.add(impulse);
    };
}

import Vec2 from '../math/Vec2';
import { Arbiter, ArbiterKey } from './Arbiter';
import Body from './Body';
import Joint from './Joint';

export default class World {
    bodies: Body[] = [];
    joints: Joint[] = [];

    arbiters: Map<number, Arbiter> = new Map();

    gravity: Vec2;
    iterations: number;

    static accumulateImpulses = true;
    static warmStarting = true;
    static positionCorrection = true;

    constructor(gravity: Vec2, iterations: number) {
        this.gravity = gravity;
        this.iterations = iterations;
    }

    add(body: Body): void;
    add(joint: Joint): void;

    add(element: Body | Joint): void {
        if (element instanceof Body) {
            this.bodies.push(element);
        } else if (element instanceof Joint) {
            this.joints.push(element);
        } else {
            throw new Error('Invalid argument');
        }
    }

    clear = (): void => {
        this.bodies.length = 0;
        this.joints.length = 0;
        this.arbiters.clear();
    };

    broadPhase = () => {
        // O(n^2) broad-phase
        for (let i = 0; i < this.bodies.length; i++) {
            const bi = this.bodies[i];

            for (let j = i + 1; j < this.bodies.length; j++) {
                const bj = this.bodies[j];

                if (bi.invMass === 0 && bj.invMass === 0) {
                    continue;
                }

                const newArb = new Arbiter(bi, bj);
                const key = ArbiterKey.getKey(bi, bj);

                if (newArb.numContacts > 0) {
                    if (!this.arbiters.has(key)) {
                        this.arbiters.set(key, newArb);
                    } else {
                        this.arbiters.get(key)!.update(newArb.contacts, newArb.numContacts);
                    }
                } else {
                    this.arbiters.delete(key);
                }
            }
        }
    };

    step = (dt: number) => {
        const invDt = dt > 0.0 ? 1.0 / dt : 0.0;

        // Determine overlapping bodies and update contact points.
        this.broadPhase();

        // Integrate forces.
        for (let i = 0; i < this.bodies.length; i++) {
            const b = this.bodies[i];

            if (b.invMass === 0.0) {
                continue;
            }

            b.velocity.add(Vec2.scale(dt, Vec2.add(this.gravity, Vec2.scale(b.invMass, b.force))));
            b.angularVelocity += dt * b.invI * b.torque;
        }

        // Perform pre-steps.
        for (const arbiter of this.arbiters.values()) {
            arbiter.preStep(invDt);
        }

        for (const joint of this.joints) {
            joint.preStep(invDt);
        }

        // Perform iterations
        for (let i = 0; i < this.iterations; i++) {
            for (const arbiter of this.arbiters.values()) {
                arbiter.applyImpulse();
            }

            for (const joint of this.joints) {
                joint.applyImpulse();
            }
        }

        // Integrate Velocities
        for (let i = 0; i < this.bodies.length; i++) {
            const b = this.bodies[i];

            b.position.add(Vec2.scale(dt, b.velocity));
            b.rotation += dt * b.angularVelocity;

            b.force.set(0, 0);
            b.torque = 0.0;
        }
    };
}

import Utils from '../math/Utils';
import Vec2 from '../math/Vec2';
import Body from '../physics/Body';
import Joint from '../physics/Joint';
import World from '../physics/World';

export default class Demo {
    static demoStrings = [
        'Demo 1: A Single Box',
        'Demo 2: Simple Pendulum',
        'Demo 3: Varying Friction Coefficients',
        'Demo 4: Randomized Stacking',
        'Demo 5: Pyramid Stacking',
        'Demo 6: A Teeter',
        'Demo 7: A Suspension Bridge',
        'Demo 8: Dominos',
        'Demo 9: Multi-pendulum',
    ];

    static demo1 = (world: World) => {
        // Demo1: Single box
        const floor = new Body();
        floor.set(new Vec2(100, 20), Number.MAX_VALUE);
        floor.position.set(0, -0.8 * floor.width.y);
        world.add(floor);

        const box1 = new Body();
        box1.set(new Vec2(1, 1), 200);
        box1.position.set(0, 1);
        world.add(box1);
    };

    static demo2 = (world: World) => {
        // Demo 2: A simple pendulum
        const floor = new Body();
        floor.set(new Vec2(100, 20), Number.MAX_VALUE);
        floor.friction = 0.2;
        floor.position.set(0, -0.8 * floor.width.y);
        floor.rotation = 0;
        world.add(floor);

        const box = new Body();
        box.set(new Vec2(1, 1), 100);
        box.friction = 0.2;
        box.position.set(9, 5);
        box.rotation = 0;
        world.add(box);

        const j = new Joint();
        j.set(floor, box, new Vec2(0, 5));
        world.add(j);
    };

    static demo4 = (world: World) => {
        // Demo 4: A vertical stack
        const floor = new Body();
        floor.set(new Vec2(100, 20), Number.MAX_VALUE);
        floor.friction = 0.2;
        floor.position.set(0, -0.8 * floor.width.y);
        floor.rotation = 0;
        world.add(floor);

        for (let i = 0; i < 10; i++) {
            const box = new Body();
            box.set(new Vec2(1, 1), 1);
            box.friction = 0.2;
            const x = Utils.random(-0.1, 0.1);
            box.position.set(x, -4 + 1.05 * i);
            world.add(box);
        }
    };
}
